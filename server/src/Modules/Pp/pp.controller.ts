import {
  BadRequestException,
  Body,
  Controller,
  HttpStatus,
  Post,
  Req,
  Res,
} from "@nestjs/common";
import { ApiOperation } from "@nestjs/swagger";
import * as _ from "lodash";
import { v4 as uuidv4 } from "uuid";

import { AccessCodeService } from "../../Global/Service/access.code.service";
import apiPath from "../../Config/api.path";

import { PpService } from "./pp.service";
import { FAILED, SUCCESS } from "../../Config/result.code";
import { ApiService } from "../../Infrastructure/Api/api.service";
import { Config, Game } from "../../Config/config";
import { CallbackType, Lang } from "./Enum/pp.enum";
import {
  AuthDto,
  BalanceDto,
  BetDto,
  BonusWinDto,
  EndRoundDto,
  JackpotWinDto,
  PromoWinDto,
  RefundDto,
  ResultDto,
} from "./Dto/pp.dto";
import {
  ObjData,
  ObjThirdParty,
  ProcessRequest,
} from "../../Grpc/Clients/Interface/core.service.interface";
import { CoreGrpcService } from "../../Grpc/Clients/core.grpc.service";
import {
  BalanceResponse,
  BetResponse,
  BonusWinResponse,
  EndRoundResponse,
  JackpotWinResponse,
  PromoWinResponse,
  ResultResponse,
} from "./Interface/pp.interface";

@Controller()
export class PpController {
  constructor(
    private readonly accessCodeService: AccessCodeService,
    private readonly ppService: PpService,
    private readonly apiService: ApiService,
    private readonly coreGrpcService: CoreGrpcService,
  ) { }

  @Post(apiPath.pp.session)
  @ApiOperation({
    summary: "session ??",
  })
  async session(@Req() req, @Body() body): Promise<any> {
    const rawIP = req?.ip?.replace("::ffff:", "") || "unknown";
    const allowList = Config.MAIN_APP_IP || [];
    const isAllowed = allowList.includes(rawIP);
    if (!isAllowed) {
      return { result: FAILED };
    }

    await this.accessCodeService.addUserObj(
      body?.user_id,
      Game.PP.cp_key.toString(),
      body.token,
    );
    await this.accessCodeService.addUserObj(
      body?.token?.sg,
      Game.PP.cp_key.toString(),
      body.token,
    );

    return { result: SUCCESS };
  }

  @Post(apiPath.pp.auth)
  @ApiOperation({
    summary:
      "When the game is opening Pragmatic Play receives with URL security token generated by Casino Operator. Using this token" +
      "Pragmatic Play will ask Casino Operator for player authentication and get the player’s balance",
  })
  async auth(@Body() body, @Res() res): Promise<any> {
    // body is query style, etc. providerId=pragmaticplay&hash=e1467eb30743fb0a180ed141a26c58f7&token=5v93mto7jr
    const bodyObj: AuthDto = { ...body };
    // [todo] send auth log api.
    // g_callback.svc_log.send( { trace: req.trace, type: g_cx.config.SERVICE_LOG_SERVER.type.cp_req_svc, callback_type: g_cx.config.CALLBACK_TYPE.MEMBER_CHECK, data: objData } );
    const userObj = await this.accessCodeService.getUserObj(
      bodyObj.token,
      Game.PP.cp_key.toString(),
    );
    if (!userObj) {
      // [todo] send auth log api.
      // g_callback.svc_log.send( { trace: req.trace, type: g_cx.config.SERVICE_LOG_SERVER.type.svc_res_cp, callback_type: g_cx.config.CALLBACK_TYPE.MEMBER_CHECK, data: objError } );
      res.send({
        error: 4,
        description: "invalid token",
        trace: bodyObj.trace,
      });
    }

    // check userObj required properties: { key, id, op, dt }
    const inValid = this.accessCodeService.inValidToken(userObj);
    if (inValid) {
      res.send({ error: 4, description: "invalid key", trace: bodyObj.trace });
    }

    const objThirdparty = this.ppService.getThirdPartObjByCpKey(
      userObj?.c?.toString() ?? "0",
    );

    // call gRPC
    const objParam: ObjData = {
      round_id: uuidv4(),
      trans_id: uuidv4(),
      amount: 0,
      game_code: "",
      table_code: "",
      game_type: "",
      event_type: 0,
      trace: body.trace,
      is_end: false,
      is_cancel_round: false,
      is_end_check: false,
      cp_data: "",
    };

    const processRequestObj = this.accessCodeService.buildProcessRequest({
      body,
      callbackType: CallbackType.MemberCheck,
      objUser: userObj,
      objThirdParty: objThirdparty,
      objData: objParam,
      lang: Lang.ko,
    });

    const reply = await this.coreGrpcService.processCall(processRequestObj);
    const { result, error } = reply;
    if (error) {
      throw new BadRequestException({
        code: error.statuscode,
        message: error.msg,
      });
    }

    // 等待確認 spec
    const apiResult = this.ppService.buildServiceResult(
      result,
      userObj,
      objThirdparty,
      CallbackType.MemberCheck,
    );
    res.send(apiResult);
  }

  @Post(apiPath.pp.balance)
  @ApiOperation({
    summary:
      "Using this method a Pragmatic Play system will know a current balance of player and will show it in the game.",
  })
  async balance(@Body() body, @Res() res): Promise<BalanceResponse> {
    const reqData: BalanceDto = { ...body };
    const response = <BalanceResponse>{};

    // [todo] send log api.

    const userObj = await this.accessCodeService.getUserObj(
      reqData.userId,
      Game.PP.cp_key.toString(),
    );
    if (!userObj) {
      // [todo] send log api.
      res.send({ error: 4, description: "invalid token", trace: body.trace });
    }

    // check userObj required properties: { key, id, op, dt }
    const inValid = this.accessCodeService.inValidToken(userObj);
    if (inValid) {
      res.send({ error: 4, description: "invalid key", trace: body.trace });
    }

    const objThirdparty = this.ppService.getThirdPartObjByCpKey(
      userObj?.c?.toString() ?? "0",
    );

    // call gRPC
    const objParam: ObjData = {
      round_id: uuidv4(),
      trans_id: uuidv4(),
      amount: 0,
      game_code: "",
      table_code: "",
      game_type: "",
      event_type: 0,
      trace: body.trace,
      is_end: false,
      is_cancel_round: false,
      is_end_check: false,
      cp_data: "",
    };

    const processRequestObj = this.accessCodeService.buildProcessRequest({
      body,
      callbackType: CallbackType.Balance,
      objUser: userObj,
      objThirdParty: objThirdparty,
      objData: objParam,
      lang: Lang.ko,
    });

    const reply = await this.coreGrpcService.processCall(processRequestObj);
    const { result, error } = reply;
    if (error) {
      throw new BadRequestException({
        code: error.statuscode,
        message: error.msg,
      });
    }

    // 等待確認 spec
    const apiResult = this.ppService.buildServiceResult(
      result,
      userObj,
      objThirdparty,
      CallbackType.Balance,
    );
    response.bonus = apiResult.bonus;
    response.cash = apiResult.cash;
    response.currency = apiResult.currency;
    response.error = apiResult.error;
    response.description = apiResult.description;

    return res.send(response);
  }

  @Post(apiPath.pp.bet)
  @ApiOperation({
    summary:
      "Using this method Pragmatic Play system will check the player balance on Casino Operator side to ensure they still have the" +
      "funds to cover the bet. Amount of the bet must be subtracted from player balance in Casino Operator system.",
  })
  async bet(@Body() body, @Res() res): Promise<BetResponse> {
    const reqData: BetDto = { ...body };
    const response = <BetResponse>{};

    // [todo] send log api.

    const userObj = await this.accessCodeService.getUserObj(
      reqData.userId,
      Game.PP.cp_key.toString(),
    );
    if (!userObj) {
      // [todo] send log api.
      res.send({ error: 4, description: "invalid token", trace: body.trace });
    }

    // check userObj required properties: { key, id, op, dt }
    const inValid = this.accessCodeService.inValidToken(userObj);
    if (inValid) {
      res.send({
        error: 4,
        description: "Membership verification failure",
        trace: body.trace,
      });
    }

    const strGameType = this.ppService.isCasino(reqData.gameId)
      ? Config.GAMECODE.LIVE
      : Config.GAMECODE.SLOT;
    const objThirdparty = this.ppService.getThirdPartyObject(
      reqData.gameId,
      userObj.c.toString(),
    );
    const tableInfo = await this.accessCodeService.getTableInfo(
      Game.PP_LIVE.cp_key.toString(),
      reqData.gameId,
    );
    // // call gRPC
    const objParam: ObjData = {
      round_id: uuidv4(),
      trans_id: uuidv4(),
      amount: Math.abs(parseFloat(Number(reqData?.amount).toFixed(2))),
      game_code: reqData.gameId,
      table_code: tableInfo?.name ?? "",
      game_type: strGameType,
      event_type: Config.BET_EVENT_TYPE.NORMAL,
      trace: body.trace,
      is_end: false,
      is_cancel_round: false,
      is_end_check: false,
      cp_data: "",
    };

    const processRequestObj = this.accessCodeService.buildProcessRequest({
      body,
      callbackType: CallbackType.Bet,
      objUser: userObj,
      objThirdParty: objThirdparty,
      objData: objParam,
      lang: Lang.ko,
    });

    const reply = await this.coreGrpcService.processCall(processRequestObj);
    const { result, error } = reply;
    if (error) {
      throw new BadRequestException({
        code: error.statuscode,
        message: error.msg,
      });
    }

    // 等待確認 spec
    const apiResult = this.ppService.buildServiceResult(
      result,
      userObj,
      objThirdparty,
      CallbackType.Bet,
    );
    response.transactionId = apiResult.transactionId;
    response.currency = apiResult.currency;
    response.cash = apiResult.cash;
    response.bonus = apiResult.bonus;
    response.error = apiResult.error;
    response.description = apiResult.description;

    return res.send(response);
  }

  @Post(apiPath.pp.result)
  @ApiOperation({
    summary:
      "Using this method the Pragmatic Play system will send to Casino Operator the winning result of a bet. The Casino Operator" +
      "will change the balance of the player in accordance with this request and return the updated balance." +
      "Result request may contain a prize that the player is awarded with during the game round, if there is an active promotional" +
      "campaigns like Prize Drop. Parameters related to the Prize Drop prizes are optional and should be configured by" +
      "PragmaticPlay team based on Operator’s request.",
  })
  async result(@Body() body, @Res() res): Promise<ResultResponse> {
    const reqData: ResultDto = { ...body };

    // [todo] send log api.

    const userObj = await this.accessCodeService.getUserObj(
      reqData.userId,
      Game.PP.cp_key.toString(),
    );
    if (!userObj) {
      // [todo] send log api.
      res.send({ error: 4, description: "invalid token", trace: body.trace });
    }

    // check userObj required properties: { key, id, op, dt }
    const inValid = this.accessCodeService.inValidToken(userObj);
    if (inValid) {
      // [todo] send log api.
      res.send({
        error: 4,
        description: "Membership verification failure",
        trace: body.trace,
      });
    }

    const strGameType = this.ppService.isCasino(reqData.gameId)
      ? Config.GAMECODE.LIVE
      : Config.GAMECODE.SLOT;
    const objThirdparty = this.ppService.getThirdPartyObject(
      reqData.gameId,
      userObj.c.toString(),
    );
    const tableInfo = await this.accessCodeService.getTableInfo(
      Game.PP_LIVE.cp_key.toString(),
      reqData.gameId,
    );
    // bPromoWin > 決定是否呼叫第二次 gRPC
    const bPromoWin =
      !_.isNull(reqData.promoWinAmount) &&
        parseFloat(reqData.promoWinAmount) !== 0
        ? true
        : false;
    const objParam: ObjData = {
      round_id: uuidv4(),
      trans_id: uuidv4(),
      amount: Math.abs(parseFloat(Number(reqData?.amount).toFixed(2))),
      game_code: reqData.gameId,
      table_code: tableInfo?.name ?? "",
      game_type: strGameType,
      event_type: Config.BET_EVENT_TYPE.NORMAL,
      trace: body.trace,
      is_end: !bPromoWin,
      is_cancel_round: false,
      is_end_check: false,
      cp_data: "",
    };

    const processRequestObj = this.accessCodeService.buildProcessRequest({
      body,
      callbackType: CallbackType.Result,
      objUser: userObj,
      objThirdParty: objThirdparty,
      objData: objParam,
      lang: Lang.ko,
    });

    const reply = await this.coreGrpcService.processCall(processRequestObj);
    const { result, error } = reply;
    if (error) {
      throw new BadRequestException({
        code: error.statuscode,
        message: error.msg,
      });
    }
    const apiResult = this.ppService.buildServiceResult(
      result,
      userObj,
      objThirdparty,
      CallbackType.Result,
    );
    if (!bPromoWin || apiResult.error !== 0) {
      // api return result
      if (apiResult.error === 20202 || apiResult.error === 20206) {
        // 이미 처리한 결과 0으로 강제전송
        apiResult.error = 0;
        apiResult.description = "Success";
      }
      // [todo] send log api.
      return res.send(apiResult);
    }

    // call gRPC run2
    const objParam2: ObjData = {
      round_id: reqData.roundId,
      trans_id: reqData.promoWinReference,
      amount: Math.abs(Number(reqData?.promoWinAmount)),
      game_code: reqData.gameId,
      table_code: tableInfo?.name ?? "",
      game_type: strGameType,
      event_type: Config.BET_EVENT_TYPE.EVENT_CASH,
      is_end: true,
      trace: body.trace,
      is_cancel_round: false,
      is_end_check: false,
      cp_data: "",
    };

    const processRequestObj2 = this.accessCodeService.buildProcessRequest({
      body,
      callbackType: CallbackType.Result,
      objUser: userObj,
      objThirdParty: objThirdparty,
      objData: objParam2,
      lang: Lang.ko,
    });

    const reply2 = await this.coreGrpcService.processCall(processRequestObj2);
    const { result: result2, error: error2 } = reply2;
    if (error2) {
      throw new BadRequestException({
        code: error2.statuscode,
        message: error2.msg,
      });
    }
    const apiResult2 = this.ppService.buildServiceResult(
      result2,
      userObj,
      objThirdparty,
      CallbackType.Result,
    );

    // 特殊處理
    if (apiResult2.hasOwnProperty("transactionId")) {
      apiResult2.transactionId = apiResult.transactionId;
    }

    // 이미 처리한 결과 0으로 강제전송
    if (apiResult2.error !== 0) {
      if (objParam2?.amount !== 0 && !_.isNull(reqData?.bonusCode)) {
        // this.ppService.updateBonus(reqData.bonusCode, reqData.userId, 0, objParam.amount);
        // 原伺服器方法為空的, TODO?
      }
      if (apiResult2.error === 20202 || apiResult2.error === 20206) {
        // 이미 처리한 결과 0으로 강제전송
        apiResult2.error = 0;
        apiResult2.description = "Success";
      }
      // TODO: send log api.
      return res.send(apiResult2);
    }

    // [todo] send log api.
    return res.send(apiResult2);
  }

  @Post(apiPath.pp.refund)
  @ApiOperation({
    summary:
      "Pragmatic Play system may use this method to rollback a bet transaction on the Casino Operator side, in order to reverse" +
      "the transaction and adjust player’s balance. When receive a Refund request Operator have to return money back to player’s " +
      "balance. ",
  })
  async refund(@Body() body, @Res() res): Promise<ResultResponse> {
    const reqData: RefundDto = { ...body };

    // [todo] send log api.

    const userObj = await this.accessCodeService.getUserObj(
      reqData.userId,
      Game.PP.cp_key.toString(),
    );
    if (!userObj) {
      // [todo] send log api.
      res.send({ error: 4, description: "invalid token", trace: body.trace });
    }

    // check userObj required properties: { key, id, op, dt }
    const inValid = this.accessCodeService.inValidToken(userObj);
    if (inValid) {
      // [todo] send log api.
      res.send({
        error: 4,
        description: "Membership verification failure",
        trace: body.trace,
      });
    }

    const strGameType = this.ppService.isCasino(reqData.gameId)
      ? Config.GAMECODE.LIVE
      : Config.GAMECODE.SLOT;
    const objThirdparty = this.ppService.getThirdPartyObject(
      reqData.gameId,
      userObj.c.toString(),
    );
    const tableInfo = await this.accessCodeService.getTableInfo(
      Game.PP_LIVE.cp_key.toString(),
      reqData.gameId,
    );

    let strRoundID = "";
    let fAmount = 0;
    if (!reqData?.roundId || !reqData?.amount) {
      let objFindTrans = await this.ppService.getTransData(reqData?.reference);
      if (!_.isNil(objFindTrans)) {
        strRoundID = objFindTrans?.thirdparty_round_id;
        fAmount = objFindTrans?.amount;
      }
    } else {
      strRoundID = reqData.roundId;
      fAmount = parseFloat(reqData.amount.toString());
    }

    const objParam: ObjData = {
      round_id: strRoundID,
      trans_id: reqData.reference,
      amount: Math.abs(Number(fAmount)),
      game_code: reqData.gameId || "",
      table_code: tableInfo?.name ?? "",
      game_type: strGameType,
      event_type: Config.BET_EVENT_TYPE.NORMAL,
      trace: body.trace,
      is_end: false,
      is_cancel_round: false,
      is_end_check: false,
      cp_data: "",
    };
    const processRequestObj = this.accessCodeService.buildProcessRequest({
      body,
      callbackType: CallbackType.Refund,
      objUser: userObj,
      objThirdParty: objThirdparty,
      objData: objParam,
      lang: Lang.ko,
    });

    const reply = await this.coreGrpcService.processCall(processRequestObj);
    const { result, error } = reply;
    if (error) {
      throw new BadRequestException({
        code: error.statuscode,
        message: error.msg,
      });
    }
    const apiResult = this.ppService.buildServiceResult(
      result,
      userObj,
      objThirdparty,
      CallbackType.Refund,
    );
    if (apiResult.error !== 0) delete apiResult["transactionId"];

    if (apiResult.error == 20203) {
      apiResult.error = 0;
      apiResult.description = "Success";
    }

    // [todo] send log api.
    return apiResult;
  }

  @Post(apiPath.pp.bonusWin)
  @ApiOperation({
    summary:
      "Using this method a Pragmatic Play system will send to Casino Operator winning result of all rounds played on Free Spins" +
      "Bonus. Casino Operator will change a player balance in appliance with this request and will return an updated balance.",
  })
  async bonusWin(@Body() body, @Res() res): Promise<BonusWinResponse> {
    const reqData: BonusWinDto = { ...body };

    // [todo] send log api.

    const userObj = await this.accessCodeService.getUserObj(
      reqData.userId,
      Game.PP.cp_key.toString(),
    );
    if (!userObj) {
      // [todo] send log api.
      res.send({ error: 4, description: "invalid token", trace: body.trace });
    }

    // check userObj required properties: { key, id, op, dt }
    const inValid = this.accessCodeService.inValidToken(userObj);
    if (inValid) {
      // [todo] send log api.
      res.send({
        error: 4,
        description: "Membership verification failure",
        trace: body.trace,
      });
    }

    const objParam: ObjData = {
      round_id: uuidv4(),
      trans_id: uuidv4(),
      amount: Math.abs(Number(reqData?.amount)),
      game_code: "",
      table_code: "",
      game_type: "",
      event_type: Config.BET_EVENT_TYPE.NORMAL,
      trace: body.trace,
      is_end: false,
      is_cancel_round: false,
      is_end_check: false,
      cp_data: "",
    };
    const nullObjThirdparty = this.accessCodeService.getNullObjThirdparty();
    const processRequestObj = this.accessCodeService.buildProcessRequest({
      body,
      callbackType: CallbackType.Balance,
      objUser: userObj,
      objThirdParty: nullObjThirdparty,
      objData: objParam,
      lang: Lang.ko,
    });

    const reply = await this.coreGrpcService.processCall(processRequestObj);
    const { result, error } = reply;
    if (error) {
      throw new BadRequestException({
        code: error.statuscode,
        message: error.msg,
      });
    }
    const apiResult = this.ppService.buildServiceResult(
      result,
      userObj,
      nullObjThirdparty,
      CallbackType.Balance,
    );
    if (apiResult.error === 0) apiResult.transactionId = result.trans_id;

    // [todo] send log api.
    return apiResult;
  }

  @Post(apiPath.pp.jackpotWin)
  @ApiOperation({
    summary:
      "Using this method a Pragmatic Play system will notify Casino Operator about Jackpot winning. Operator should handle the" +
      "transaction in their system and send the jackpot win transaction id back to the Pragmatic Play.",
  })
  async jackpotWin(@Body() body, @Res() res): Promise<JackpotWinResponse> {
    const reqData: JackpotWinDto = { ...body };
    // [todo] send log api.

    const userObj = await this.accessCodeService.getUserObj(
      reqData.userId,
      Game.PP.cp_key.toString(),
    );
    if (!userObj) {
      // [todo] send log api.
      res.send({ error: 4, description: "invalid token", trace: body.trace });
    }

    // check userObj required properties: { key, id, op, dt }
    const inValid = this.accessCodeService.inValidToken(userObj);
    if (inValid) {
      // [todo] send log api.
      res.send({
        error: 4,
        description: "Membership verification failure",
        trace: body.trace,
      });
    }

    let objParam: ObjData = {
      round_id: reqData.roundId,
      trans_id: reqData.reference,
      amount: Math.abs(parseFloat(reqData?.amount.toString())),
      game_code: reqData.gameId,
      table_code: await this.accessCodeService.getTableInfo(
        Game.PP.cp_key.toString(),
        reqData.gameId,
      ),
      game_type: this.ppService.isCasino(reqData.gameId)
        ? Config.GAMECODE.LIVE
        : Config.GAMECODE.SLOT,
      event_type: Config.BET_EVENT_TYPE.EVENT_CASH,
      trace: body.trace,
      is_end: false,
      is_cancel_round: false,
      is_end_check: false,
      cp_data: "",
    };
    const nullObjThirdparty = this.accessCodeService.getNullObjThirdparty();
    const processRequestObj = this.accessCodeService.buildProcessRequest({
      body,
      callbackType: CallbackType.Result,
      objUser: userObj,
      objThirdParty: nullObjThirdparty,
      objData: objParam,
      lang: Lang.ko,
    });

    const reply = await this.coreGrpcService.processCall(processRequestObj);
    const { result, error } = reply;
    if (error) {
      throw new BadRequestException({
        code: error.statuscode,
        message: error.msg,
      });
    }
    const apiResult = this.ppService.buildServiceResult(
      result,
      userObj,
      nullObjThirdparty,
      CallbackType.Result,
    );
    if (apiResult.error !== 0) {
      //	이미 처리한 결과 0으로 강제전송
      if (apiResult.error === 20202 || apiResult.error === 20206) {
        apiResult.error = 0;
        apiResult.description = "Success";
      }
    }

    // [todo] send log api.
    return apiResult;
  }

  @Post(apiPath.pp.promoWin)
  @ApiOperation({
    summary:
      "Using this method the Pragmatic Play system will notify Casino Operator about winning that the player is awarded as a" +
      "result of a campaign that is finished. Notification is asynchronous and may come to the operator with a short delay after the" +
      "campaign is over. Operator should handle the transaction in their system and send promo win transaction id back to the" +
      "Pragmatic Play",
  })
  async promoWin(@Body() body, @Res() res): Promise<PromoWinResponse> {
    const reqData: PromoWinDto = { ...body };

    const userObj = await this.accessCodeService.getUserObj(
      reqData.userId,
      Game.PP.cp_key.toString(),
    );
    if (!userObj) {
      // [todo] send log api.
      res.send({ error: 4, description: "invalid token", trace: body.trace });
    }

    // check userObj required properties: { key, id, op, dt }
    const inValid = this.accessCodeService.inValidToken(userObj);
    if (inValid) {
      // [todo] send log api.
      res.send({
        error: 4,
        description: "Membership verification failure",
        trace: body.trace,
      });
    }

    // call gRPC
    const objParam: ObjData = {
      round_id: body.reference ?? uuidv4(),
      trans_id: body.reference ?? uuidv4(),
      amount: 0,
      game_code: body.campaignId,
      game_type: Config.GAMECODE.SLOT,
      event_type: Config.BET_EVENT_TYPE.EVENT_CASH,
      trace: body.trace,
      is_end: false,
      is_cancel_round: false,
      is_end_check: false,
      cp_data: "",
      table_code: "",
    };
    const nullObjThirdparty = this.accessCodeService.getNullObjThirdparty();
    const processRequestObj = this.accessCodeService.buildProcessRequest({
      body,
      callbackType: CallbackType.Bet,
      objUser: userObj,
      objThirdParty: nullObjThirdparty,
      objData: objParam,
      lang: Lang.ko,
    });
    const reply = await this.coreGrpcService.processCall(processRequestObj);
    const { result, error } = reply;
    if (error) {
      throw new BadRequestException({
        code: error.statuscode,
        message: error.msg,
      });
    }
    const apiResult = this.ppService.buildServiceResult(
      result,
      userObj,
      nullObjThirdparty,
      CallbackType.Result,
    );
    if (apiResult.error !== 0 && apiResult.error !== 20201) {
      // [todo] send log api.
      res.send(apiResult); // * 沒有錯誤直接回傳
    }

    // call 2 : 有錯誤進行第二次呼叫
    const objParam2: ObjData = {
      round_id: body.reference ?? uuidv4(),
      trans_id: ["pw-", body.reference].join(""),
      amount: Math.abs(parseFloat(body?.amount)),
      game_code: body.campaignId,
      game_type: Config.GAMECODE.SLOT,
      event_type: Config.BET_EVENT_TYPE.EVENT_CASH,
      is_end: true,
      trace: body.trace ?? uuidv4(),
      is_cancel_round: false,
      is_end_check: false,
      cp_data: "",
      table_code: "",
    };
    const processRequestObj2 = this.accessCodeService.buildProcessRequest({
      body,
      callbackType: CallbackType.Result,
      objUser: userObj,
      objThirdParty: nullObjThirdparty,
      objData: objParam2,
      lang: Lang.ko,
    });
    const reply2 = await this.coreGrpcService.processCall(processRequestObj2);
    const { result: result2, error: error2 } = reply2;
    if (error2) {
      throw new BadRequestException({
        code: error2.statuscode,
        message: error2.msg,
      });
    }
    const apiResult2 = this.ppService.buildServiceResult(
      result2,
      userObj,
      nullObjThirdparty,
      CallbackType.Result,
    );
    if (
      apiResult2.error !== 0 &&
      (apiResult2.error === 20201 || apiResult2.error === 20202)
    ) {
      //	이미 처리한 결과 0으로 강제전송
      apiResult2.error = 0;
      apiResult2.description = "Success";
    }

    // [todo] send log api.
    return apiResult;
  }

  @Post(apiPath.pp.endround)
  @ApiOperation({
    summary:
      "Every time a game round is over, the Pragmatic Play system will call EndRound method, so that Operator can finalize the" +
      "game round transactions on their side in real time.",
  })
  async endround(@Body() body, @Res() res): Promise<EndRoundResponse> {
    const reqData: EndRoundDto = { ...body };

    // [todo] send log api.

    const userObj = await this.accessCodeService.getUserObj(
      reqData.userId,
      Game.PP.cp_key.toString(),
    );
    if (!userObj) {
      res.send({ error: 4, description: "invalid token", trace: body.trace });
    }

    // check userObj required properties: { key, id, op, dt }
    const inValid = this.accessCodeService.inValidToken(userObj);
    if (inValid) {
      // [todo] send log api.
      res.send({
        error: 4,
        description: "Membership verification failure",
        trace: body.trace,
      });
    }

    const thirdParty = this.ppService.getThirdPartyObject(
      reqData.gameId,
      userObj.c.toString(),
    );
    const tableInfo = await this.accessCodeService.getTableInfo(
      Game.PP.cp_key.toString(),
      reqData.gameId,
    );
    const objParam: ObjData = {
      round_id: reqData.roundId ?? uuidv4(),
      trans_id: [reqData.roundId, "_end"].join("") ?? uuidv4(),
      amount: 0,
      game_code: reqData.gameId,
      table_code: tableInfo?.name ?? "",
      game_type: thirdParty?.game_type ?? "",
      event_type: Config.BET_EVENT_TYPE.NORMAL,
      is_end: true,
      trace: body.trace ?? uuidv4(),
      is_cancel_round: false,
      is_end_check: false,
      cp_data: "",
    };
    const processRequestObj = this.accessCodeService.buildProcessRequest({
      body,
      callbackType: CallbackType.Result,
      objUser: userObj,
      objThirdParty: thirdParty,
      objData: objParam,
      lang: Lang.ko,
    });

    const reply = await this.coreGrpcService.processCall(processRequestObj);
    const { result, error } = reply;
    if (error) {
      throw new BadRequestException({
        code: error.statuscode,
        message: error.msg,
      });
    }
    const apiResult = this.ppService.buildServiceResult(
      result,
      userObj,
      thirdParty,
      CallbackType.Result,
    );
    if (
      apiResult.error !== 0 &&
      (apiResult.error === 20202 || apiResult.error === 20206)
    ) {
      apiResult.error = 0;
      apiResult.description = "Success";
    }

    delete apiResult["currency"];
    delete apiResult["transactionId"];

    // [todo] send log api.
    return apiResult;
  }
}
